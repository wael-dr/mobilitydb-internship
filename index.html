<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brussels 3D Buildings</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.107/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.107/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    @import url(../templates/bucket.css);
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; }
    #debugPanel { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); 
                  color: white; padding: 10px; max-height: 200px; overflow-y: auto; width: 300px; z-index: 1000; }
    #loadingOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                     background-color: rgba(0,0,0,0.7); display: flex; justify-content: center;
                     align-items: center; color: white; font-size: 24px; z-index: 1000; }
    .control-group { margin-bottom: 8px; }
    .control-group label { display: block; margin-bottom: 3px; }
    
    /* Mobility styling */
    #vehicleControls { position: absolute; top: 140px; left: 10px; background: rgba(0,0,0,0.7);
                      color: white; padding: 10px; z-index: 1000; width: 250px; }
    #vehicleInfo { position: absolute; bottom: 10px; left: 320px; background: rgba(0,0,0,0.7);
                  color: white; padding: 10px; z-index: 1000; display: none; width: 300px; }
    .vehicle-type-toggle { margin: 5px; }
    #dataStatus { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.7);
                 color: white; padding: 5px 10px; z-index: 1000; font-size: 12px; }
  </style>
</head>
<body>
  <div id="cesiumContainer" class="fullSize"></div>
  <div id="loadingOverlay">Loading Brussels 3D Buildings...</div>
  <div id="debugPanel"></div>
  
  <!-- Vehicle controls -->
  <div id="vehicleControls">
    <h3>Public Transport</h3>
    <div class="control-group">
      <label><input type="checkbox" id="showVehicles" checked /> Show Vehicles</label>
    </div>
    <div class="control-group">
      <label for="updateIntervalSelect">Update Interval:</label>
      <select id="updateIntervalSelect">
        <option value="3000" selected>3 seconds</option>
        <option value="5000">5 seconds</option>
        <option value="10000">10 seconds</option>
        <option value="30000">30 seconds</option>
        
      </select>
    </div>
    <div>
      <button id="refreshNowButton">Refresh Now</button>
    </div>
  </div>
  
  <div id="vehicleInfo">
    <h3>Vehicle Details</h3>
    <div id="vehicleDetails">Select a vehicle to see details</div>
    <button id="closeVehicleInfo">Close</button>
  </div>
  
  <div id="dataStatus">Data: Not Connected</div>

  <script src="mobility.js"></script>
  <script src="cesium.js"></script>
  <script>
    // Set up the error handler early to catch any initialization errors
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Error caught:", message);
      document.getElementById('debugPanel').innerHTML += `ERROR: ${message}<br>`;
      document.getElementById('loadingOverlay').innerHTML = 'Error loading application. See console for details.';
      return false;
    };
    
    // Helper function for logging
    function log(message) {
      console.log(message);
      const debugPanel = document.getElementById('debugPanel');
      if (debugPanel) {
        debugPanel.innerHTML += message + '<br>';
        
        // Limit log length to prevent memory issues
        if (debugPanel.innerHTML.length > 5000) {
          debugPanel.innerHTML = debugPanel.innerHTML.substring(debugPanel.innerHTML.length - 3000);
        }
        
        // Auto-scroll to bottom
        debugPanel.scrollTop = debugPanel.scrollHeight;
      }
    }
    
    log("Starting application...");
    
    // Cesium Ion access token options - try multiple tokens and fallback options
    const CESIUM_TOKEN_OPTIONS = [
      // Try a different token that might work better
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5ODJmYWQzMS03MjlhLTRkNGMtODJlZi0zOWU3M2FlNmI0NGMiLCJpZCI6Mjc4MTgyLCJpYXQiOjE3NDAyMTgyNjZ9.X0H3GlYLXcAcyKo8XS89JRzsYY0YW6vE3RLybdxup_U'
    ];
    
    // Function to try different tokens until one works
    function tryTokens(index = 0) {
      if (index >= CESIUM_TOKEN_OPTIONS.length) {
        // All tokens failed, fall back to no-auth mode
        log("WARNING: All tokens failed. Falling back to no-auth mode.");
        initializeViewer(null);
        return;
      }
      
      Cesium.Ion.defaultAccessToken = CESIUM_TOKEN_OPTIONS[index];
      log(`Trying token option ${index+1}...`);
      
      // Test the token with a lightweight request
      Cesium.IonResource.fromAssetId(1)
        .then(() => {
          log("Token authentication successful!");
          initializeViewer(CESIUM_TOKEN_OPTIONS[index]);
        })
        .catch(error => {
          log(`Token ${index+1} failed: ${error.message}`);
          tryTokens(index + 1);
        });
    }
    
    // Handle token errors
    function handleTokenError() {
      log("ERROR: Cesium Ion token is invalid. Using fallback options.");
      document.getElementById('loadingOverlay').innerHTML = 
        'Authentication Error: Trying fallback options...<br>' +
        'This may take a moment.';
        
      // Try to continue with a basic viewer without terrain
      initializeViewer(null);
    }
    
    // Add proper error handler through window event listener instead
    window.addEventListener('error', function(event) {
      // Check if the error is related to Cesium token authentication
      if (event.message && 
          (event.message.includes('401') || 
           event.message.includes('authentication') || 
           event.message.includes('access token')) && 
          !window.tokenErrorHandled) {
        window.tokenErrorHandled = true;
        handleTokenError();
      }
    });
    
    // Simplified configuration with mobility parameters
    const CONFIG = {
      qualityLevel: 2,               // Rendering quality level
      emergencyMemoryThreshold: 95,  // Only act in extreme cases
      // Add mobility view parameters
      viewDistanceThreshold: 5000,   // Camera height threshold for detail adjustment
      // Add mobility simulation settings
      mobilitySimulation: true,       // Use simulated data by default
      mobilityAutoSwitch: true        // Auto switch to simulation if API fails
    };
    
    // Define Brussels area for the single tile
    const BRUSSELS_GRID = {
      west: 4.33,
      east: 4.41,
      south: 50.83,
      north: 50.89,
      cols: 1,  // Single column
      rows: 1   // Single row
    };
    
    // Keep track of loaded tiles
    const loadedTiles = {};
    let loadedTileCount = 0;
    
    // Get tile ID based on position - always returns "full" for the single tile
    function getTileId(lon, lat) {
      if (lon < BRUSSELS_GRID.west || lon > BRUSSELS_GRID.east || 
          lat < BRUSSELS_GRID.south || lat > BRUSSELS_GRID.north) {
        return null; // Outside our grid
      }
      
      return "full"; // Single tile covering the entire area
    }
    
    // Apply extrusion to buildings in a tile with simpler processing
    function processBuildingsInTile(dataSource) {
      const entities = dataSource.entities.values;
      log(`Processing ${entities.length} buildings...`);
      
      // Process all buildings without complex batching
      for (let i = 0; i < entities.length; i++) {
        try {
          const entity = entities[i];
          if (entity && entity.polygon) {
            // Extract height from properties, or use default
            let height = 10;
            try {
              if (entity.properties && entity.properties.height) {
                const h = entity.properties.height.getValue();
                if (!isNaN(h) && h > 0) height = h;
              }
            } catch (e) {}
            
            if (height > 500) height = 50;
            
            // Apply extrusion
            entity.polygon.extrudedHeight = height;
            entity.polygon.material = Cesium.Color.fromHsl(0.6, 0.6, 0.4).withAlpha(0.8);
          }
        } catch (error) {
          console.error("Error processing entity", error);
        }
      }
      
      log(`Completed processing ${entities.length} buildings.`);
      return function() {}; // Empty cancel function
    }
    
    // Load a single tile with proper promise handling
    function loadTile(viewer, tileId) {
      if (loadedTiles[tileId]) {
        return Promise.resolve(loadedTiles[tileId]); // Already loaded
      }
      
      const filename = `tile_${tileId}.geojson`;
      log(`Loading tile: ${filename}`);
      
      const dataSource = new Cesium.GeoJsonDataSource(tileId);
      return dataSource.load(filename, {
          clampToGround: true, // Keep buildings on terrain surface
          strokeWidth: CONFIG.qualityLevel < 2 ? 0 : 1 // Reduce line rendering for better performance
        })
        .then(function() {
          try {
            // Apply visibility optimization based on distance
            const cameraPosition = viewer.camera.positionCartographic;
            const cameraHeight = cameraPosition.height;
            
            viewer.dataSources.add(dataSource);
            loadedTiles[tileId] = {
              dataSource: dataSource,
              lastAccessed: Date.now(),
              cancelProcessing: null
            };
            loadedTileCount++;
            
            // Start processing buildings in this tile
            loadedTiles[tileId].cancelProcessing = processBuildingsInTile(dataSource);
            return dataSource;
          } catch (error) {
            log(`Error setting up tile ${tileId}: ${error.message}`);
            return dataSource;
          }
        })
        .catch(function(error) {
          log(`Error loading tile ${tileId}: ${error.message}`);
          return null;
        });
    }
    
    // Load the full tile
    function loadAllTiles(viewer) {
      log("Loading the full tile...");
      
      // Load the single full tile
      loadTile(viewer, "full")
        .then(() => {
          log("Full tile loaded successfully!");
        })
        .catch(error => {
          log(`Error loading full tile: ${error.message}`);
        });
    }
    
    // Initialize the application with token consideration
    let viewer;
    function initializeViewer(token) {
      try {
        log("Initializing viewer...");
        
        // Create the Cesium viewer with or without terrain based on token availability
        const viewerOptions = {
          baseLayerPicker: true,
          geocoder: false,
          homeButton: true,
          sceneModePicker: true,
          navigationHelpButton: false,
          animation: false,
          timeline: false,
          requestRenderMode: true,
          maximumRenderTimeChange: 0.05,
          targetFrameRate: 30,
          scene3DOnly: true,
          shadows: false,
          useBrowserRecommendedResolution: true
        };
        
        // Only use terrain if we have a valid token
        if (token) {
          viewerOptions.terrainProvider = Cesium.Terrain.fromWorldTerrain({
            requestVertexNormals: false,
            requestWaterMask: false
          });
          log("Using terrain with authenticated token");
        } else {
          // Use the default EllipsoidTerrainProvider (no auth needed)
          log("Using basic ellipsoid terrain (no authentication)");
        }
        
        // Create the viewer
        viewer = new Cesium.Viewer('cesiumContainer', viewerOptions);
        
        // Initialize Cesium utilities with our viewer instance
        if (window.CesiumUtils && typeof window.CesiumUtils.initCesiumUtils === 'function') {
          const cesiumUtils = window.CesiumUtils.initCesiumUtils(viewer);
          log("Cesium utilities initialized");
        } else {
          log("WARNING: Cesium utilities not available");
        }
        
        // Add a specific error handler for Cesium
        viewer.scene.globe.tileLoadProgressEvent.addEventListener(function(queuedTileCount) {
          if (queuedTileCount === 0) {
            // All tiles loaded or attempted to load
            // Check if we had any 401 errors
            const errorElement = document.querySelector('.cesium-widget-errorPanel');
            if (errorElement && 
                errorElement.textContent && 
                errorElement.textContent.includes('401') && 
                !window.tokenErrorHandled) {
              window.tokenErrorHandled = true;
              handleTokenError();
            }
          }
        });
        
        // Ensure globe is visible with explicit settings
        viewer.scene.globe.show = true;
        viewer.scene.mode = Cesium.SceneMode.SCENE3D;
        
        // Add an explicit imagery layer if none exists
        if (viewer.imageryLayers.length === 0) {
          viewer.imageryLayers.addImageryProvider(
            new Cesium.IonImageryProvider({ assetId: 3 }) // Bing Maps Aerial
          );
        }
        
        // Set view to see the globe
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(4.37, 0, 20000000),
          orientation: {
            heading: 0,
            pitch: -Math.PI/2,
            roll: 0
          }
        });
        
        // Add a button to toggle between globe and Brussels
        const globeButton = document.createElement('button');
        globeButton.textContent = 'Toggle Globe/Brussels';
        globeButton.style.position = 'absolute';
        globeButton.style.top = '130px';
        globeButton.style.right = '10px';
        globeButton.style.zIndex = '1000';
        globeButton.style.padding = '5px 10px';
        globeButton.style.backgroundColor = 'rgba(0,0,0,0.7)';
        globeButton.style.color = 'white';
        globeButton.style.border = 'none';
        document.body.appendChild(globeButton);
        
        let showingGlobe = false;
        globeButton.addEventListener('click', function() {
          if (showingGlobe) {
            // Return to Brussels
            viewer.camera.flyTo({
              destination: Cesium.Cartesian3.fromDegrees(4.37, 50.86, 8000)
            });
          } else {
            // Show globe
            viewer.camera.flyTo({
              destination: Cesium.Cartesian3.fromDegrees(4.37, 0, 20000000),
              orientation: {
                heading: 0,
                pitch: -Math.PI/2,
                roll: 0
              }
            });
          }
          showingGlobe = !showingGlobe;
        });
        
        log("Viewer created successfully with globe enabled");
        
        // Hide the loading overlay now that the viewer is created
        document.getElementById('loadingOverlay').style.display = 'none';
        
        // Set view to Brussels, zoomed out to see all tiles
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(4.37, 50.86, 8000)
        });
        
        // Load all tiles immediately
        loadAllTiles(viewer);
        
        // Initialize mobility system after buildings are loaded
        setTimeout(function() {
          if (typeof initMobility === 'function') {
            // Pass simulation settings from global config
            if (typeof MOBILITY_CONFIG !== 'undefined') {
              MOBILITY_CONFIG.useSimulation = CONFIG.mobilitySimulation;
              MOBILITY_CONFIG.autoSwitchToSimulation = CONFIG.mobilityAutoSwitch;
            }
            initMobility(viewer);
          } else {
            log("Mobility system not available");
          }
        }, 3000);
        
      } catch (error) {
        log("FATAL ERROR: " + error.message);
        document.getElementById('loadingOverlay').innerHTML = 'Error initializing viewer. See console for details.';
      }
    }
    
    // Start trying tokens
    tryTokens();
  </script>
</body>
</html>